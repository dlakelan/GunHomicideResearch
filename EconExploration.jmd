```julia

using Distributed 
censproc = addprocs(["census.lan"]; dir = "/var/local/dlakelan/GunHomicideResearch/", exename="/home/dlakelan/julia/bin/julia")

@everywhere using Pkg
@everywhere Pkg.activate(".")

@everywhere using StatsPlots, DataFrames, DataFramesMeta, FredData, Dates, GLM, StatsBase,
    FredData, CSV, Serialization, Downloads, Interpolations, Optim, Turing, LinearAlgebra, CategoricalArrays, ReverseDiff, Memoization

@everywhere include("utilities.jl")


FrAPI = "8827e587e9702525c583c914277cdd2e"

f = Fred(FrAPI)





m2 = get_data(f,"WM2NS") # the m2 money supply


p = @df m2.data plot(:date,log.(:value))
display(p)

m2data = m2.data
m2data.logval = log.(m2data.value)
m2data.delyr = let x = (m2data.date - Date("2000-01-01")); map(x->x.value/365.0,x) end

m21999 = @subset(m2.data,:date .> Date("1999-01-01") .&& :date .< Date("2018-01-01"))

p = @df m21999 plot(:date,log.(:value))
display(p)

mod = lm(@formula( logval ~ delyr),m21999)


m2covid = @subset(m2data,:date .> Date("2020-04-01") .&& :date .< Date("2020-07-01"))

p = @df m2covid plot(:date,:logval)
display(p)

modcov = lm(@formula( logval ~ delyr),m2covid)
display(modcov)


m2postcov = @subset(m2data,:date .> Date("2020-07-01") .&& :date .< Date("2022-04-01"))

p = @df m2postcov plot(:date,:logval)
display(p)

modpostcov = lm(@formula(logval ~ delyr),m2postcov)
display(modpostcov)

cpidat = get_data(f,"CPIAUCSL")

cpidatdf = cpidat.data
cpidatdf.delyr  = map(cpidatdf.date .- Date("2000-01-01")) do x 
    x.value ./ 365.0 
end

cpidatdf.logval = log.(cpidatdf.value)

cpimod = lm(@formula(logval ~ delyr),@subset(cpidatdf,:date .> Date("1999-01-01") .&& :date .< Date("2018-01-01")))


```


# Exploring the PUMS data for state by state per-capita income distribution

```julia

@everywhere function housecost(mrg,smp,rent)::Union{Float64,Missing}
    v = [mrg smp rent]
    all(ismissing,v) ? missing : sum(map(x->ismissing(x) ? 0.0 : x,v))
end

@everywhere recalc = true



incsamps = @spawnat censproc[1] begin

    if recalc
        try 
            rm("saved/incdist.dat") 
        catch 
            nothing
        finally 
            @warn "saved/incdist.dat removed" 
        end
    end
    if isfile("saved/incdist.dat")
        incsamps = Serialization.deserialize("saved/incdist.dat")
    else
        incsamps = let ss = Dict()
            for year in 2001:2019
                for file in filter(readdir("data/pums/$year")) do x 
                            occursin(r"hus.?\.csv",x)
                    end
                    @show file
                    rmfield = year < 2008 ? :RMS : :RMSP
                    fields = [:RT,:ST,:WGTP,:NP,:HINCP,:MRGP,:RNTP,:SMP, rmfield]
                    df = CSV.read("data/pums/$year/$file",DataFrame; select=fields)
                    for r in eachrow(df)
                        if typeof(r.HINCP) == Int64 && typeof(r.NP) == Int64 && r.NP > 0 && typeof(r.WGTP) == Int64
                            if haskey(ss,(year,r.ST))
                                for i in 1:r.NP
                                    push!(ss[(year,r.ST)],(np = r.NP, inc=r.HINCP/r.NP,wght=r.WGTP,housing=housecost(r.MRGP , r.SMP, r.RNTP)/r.NP, nr = getproperty(r,rmfield)))
                                end
                            else
                                ss[(year,r.ST)] = Any[(np= r.NP, inc=r.HINCP/r.NP,wght=r.WGTP,housing=housecost(r.MRGP , r.SMP, r.RNTP)/r.NP,nr = getproperty(r,rmfield)) for i in 1:r.NP]
                            end
                        end
                    end
                end
            end
            ss
        end
        Serialization.serialize("saved/incdist.dat",incsamps)
    end
    incsamps
end

incsamps = fetch(incsamps)

fips = CSV.read("data/fipscodes.csv",DataFrame)



for r in eachrow(fips)
    stnum = r.STATE
    stcode = r.STUSAB
    h = plot(; title = "$stcode (Income/ Median Housing) Distribution",xlim=(0,15),xlab="Income/Housing Ratio",ylim=(0.0,.2))
    for i in 2001:4:2019
        if haskey(incsamps,(i,stnum))
            incs = incsamps[(i,stnum)]
            sam = sample(incs,FrequencyWeights(map(x -> x.wght,incs)),2000)
            hsamp = filter(x -> ! ismissing(x) && !isnan(x),getproperty.(sam,:housing))
            #@show hsamp
            @assert ! any(isnan,hsamp)
            @assert ! any(ismissing,hsamp)
            qh50 = 12.0 * quantile(hsamp, 0.5)
            h = density!(map(x->x.inc/qh50,sam),label=i)
        end
    end
    display(h)
    h = plot(; title = "$stcode (Income/ 20% Housing) Distribution",xlim=(0,15),xlab="Income/Housing Ratio",ylim=(0.0,.2))    
    for i in 2001:4:2019
        if haskey(incsamps,(i,stnum))
            incs = incsamps[(i,stnum)]
            sam = sample(incs,FrequencyWeights(map(x -> x.wght,incs)),2000)
            hsamp = filter(x -> ! ismissing(x) && !isnan(x),getproperty.(sam,:housing))
            #@show hsamp
            @assert ! any(isnan,hsamp)
            @assert ! any(ismissing,hsamp)
            qh20 = 12.0 * quantile(hsamp, 0.20)
            h = density!(map(x->x.inc/qh20,sam),label=i)
        end
    end
    display(h)
    h = plot(;title="$stcode (Income / Actual Housing) Distribution", xlim=(0,15),xlab="Income/Housing Ratio",ylim=(0.0,.2))
    for i in 2001:4:2019
        if haskey(incsamps,(i,stnum))
            incs = incsamps[(i,stnum)]
            sam = sample(incs,FrequencyWeights(map(x -> x.wght,incs)),2000)
            sam = filter(x -> ! ismissing(x.housing),sam)
            h = density!(map(x->x.inc/(12.0*(max(100.0,x.housing))),sam); npoints = 2048, label="$i n=$(length(sam))")
        end
    end
    display(h)
    h = plot(;title="$stcode (Rooms / Person) Distribution", xlim=(0,5),xlab="Rooms/Person Ratio",ylim=(0.0,.75))
    for i in 2001:4:2019
        if haskey(incsamps,(i,stnum))
            incs = incsamps[(i,stnum)]
            sam = sample(incs,FrequencyWeights(map(x -> x.wght,incs)),2000)
            sam = filter(x -> ! ismissing(x.np) && !ismissing(x.nr),sam)
            h = density!(map(x->x.nr/x.np,sam); npoints = 2048, label="$i n=$(length(sam))")
        endpricecounts = @by(leftjoin(items,prices,on= :item_code),:item_c
        if haskey(incsamps,(i,stnum))
            incs = incsamps[(i,stnum)]
            sam = sample(incs,FrequencyWeights(map(x -> x.wght,incs)),2000)
            sam = filter(x -> ! ismissing(x.np) && !ismissing(x.nr),sam)
            h = histogram!(map(x->x.np,sam); bins=collect(0.5:1:10.5) , normalize=true , alpha = 0.25, label="$i n=$(length(sam))")
        end
    end
    display(h)
    
end






```


# Let's take a look at how cost of living changed through time.

```julia

res = @spawnat censproc[1] let files=["data/bls/ap.data.3.Food", "data/bls/ap.area","data/bls/ap.item"]
    urls=["https://download.bls.gov/pub/time.series/ap/ap.data.3.Food","https://download.bls.gov/pub/time.series/ap/ap.area","https://download.bls.gov/pub/time.series/ap/ap.item"]
    mkpath("data/bls")
    for (u,f) = Iterators.zip(urls,files)
        Downloads.download(u,f)
    end
end
res = fetch(res)

area = @spawnat censproc[1] CSV.read("data/bls/ap.area",DataFrame)
area = fetch(area)

items = @spawnat censproc[1] CSV.read("data/bls/ap.item",DataFrame)
items = fetch(items)

prices = @spawnat censproc[1] CSV.read("data/bls/ap.data.3.Food",DataFrame)
prices = fetch(prices)
rename!(prices,strip.(names(prices)))
prices.value = tryparse.(Float64,prices.value)

prices.region = SubString.(prices.series_id,4,7)
prices.season = SubString.(prices.series_id,3,3)
prices.item_code = SubString.(prices.series_id,8,13)

prices.date = prices.year + map(x -> (tryparse(Int64,x[2:3])-1)/12.0,prices.period )

mypricelist = DataFrame(item_code = ["706111","702212","712311","703511","712211","711111",
                                        "708111","701322","711311","710212","707111"],
    shortname = ["chicken","bread","tomatoes","steak","lettuce","apples","eggs","spaghetti","oranges","cheese","tuna"],
    quantg = [453.6, 453.6, 453.6, 453.6, 453.6, 453.6, 120.0*6, 453.6, 453.6,453.6, 453.6]) # grams purchased for the given price
# to calculate egg weight, I weighed 2 eggs and multiplied by 6 for a dozen


chix = @subset(items,occursin.("Chick",:item_name))
bread = @subset(items,occursin.("Bread",:item_name))
spagh = @subset(items,occursin.("Spag",:item_name))
tomat = @subset(items,occursin.("Tomato",:item_name))
lett = @subset(items,occursin.("Lett",:item_name))
orang = @subset(items,occursin.("Orange",:item_name))
pean = @subset(items,occursin.("Peanut",:item_name))
appl = @subset(items,occursin.("Apples",:item_name))
beef = @subset(items,occursin.("eef",:item_name) .|| occursin.("roast",:item_name) .|| occursin.("Steak",:item_name))
tuna = @subset(items,occursin.("una",:item_name))

# hand picked matches for the items in the fdc_id usda foods
mypricelist.fdc_id = [171450,172686,170457,168694,169248,168201,172183,168937,169918,173414,173709]


pricecounts = @by(leftjoin(items,prices,on= :item_code),:item_code,:N = length(:value),:dmin = minimum(:year),:dmax=maximum(:year))

gooditems = leftjoin(@subset(pricecounts, :N .> 1000 .&& :dmin .< 1999),items,on=:item_code)


myindex = leftjoin(mypricelist,gooditems,on=:item_code)


myprices = leftjoin(myindex,prices;on = :item_code)

# grab food nutrition data from USDA

getifnotthere("data/FoodData_Central_foundation_food_csv_2022-04-28.zip","https://fdc.nal.usda.gov/fdc-datasets/FoodData_Central_foundation_food_csv_2022-04-28.zip")
getifnotthere("data/FoodData_Central_sr_legacy_food_csv_2019-04-02.zip","https://fdc.nal.usda.gov/fdc-datasets/FoodData_Central_sr_legacy_food_csv_%202019-04-02.zip")
getifnotthere("data/FoodData_Central_Supporting_Data_csv_2022-04-28.zip","https://fdc.nal.usda.gov/fdc-datasets/FoodData_Central_Supporting_Data_csv_2022-04-28.zip")

cwd = pwd()
try 
    cd("./data")
    if !ispath("FoodData_Central_foundation_food_csv_2022-04-28")
        run(`unzip -u FoodData_Central_foundation_food_csv_2022-04-28.zip`)
    end
    mkpath("FoodData_Central_legacy"; mode=0o755)
    cd("FoodData_Central_legacy")
    run(`unzip -u ../FoodData_Central_sr_legacy_food_csv_2019-04-02.zip`)
    cd("..")
    run(`unzip -u FoodData_Central_Supporting_Data_csv_2022-04-28.zip`)
finally 
    cd(cwd)
end

# legacy foods is by far the more complete dataset even if it's less detailed, we match 
# the price data to the nearest food items in the USDA database, then get calories, protein, fat, carbs
# for each food. measured in per 100g

usdafoods = CSV.read("data/FoodData_Central_legacy/food.csv",DataFrame)


usdanutrient = CSV.read("data/FoodData_Central_legacy/food_nutrient.csv",DataFrame)

pricelistnutr = leftjoin(mypricelist,usdafoods; on=:fdc_id)

pricelistnutdetails = leftjoin(pricelistnutr,usdanutrient; on = :fdc_id)

pricelistsum = @by pricelistnutdetails :fdc_id begin
    :calories = sum(:amount[:nutrient_id .== 1008])
    :protein = sum(:amount[:nutrient_id .== 1003])
    :fat = sum(:amount[:nutrient_id .== 1004])
    :carbs = sum(:amount[:nutrient_id .== 1005])
    end

pricelistnutr = leftjoin(pricelistnutr,pricelistsum;on=:fdc_id)



function bumprbf(x)
    (x < -1.0 || x > 1.0) && return zero(x)
    exp(1.0-1.0/(1.0-x^2))
end


function rbfeval(x,c,sc,coeff,offs)
    sum(co * bumprbf((x-cent)/sc) for (cent,co) in zip(c,coeff))+offs
end


# example plot to make sure it's working
#plot(x->rbfeval(x,collect(-10.0:10.0),3.0,collect(1.0/(x^2+1.0) for x in -10:10),1.0),xlim=(-10.0,10.0))



@model function cpifood(date,item,nitem,region,nregion,centers,rbfsc,price,cals,prot,fat,carb)
    # a model of a food price index for 2000 calories a day of food 
    # chosen in a moderately healthy balance, interpolating missing prices
    # and with regional variations. input prices should be in $/100g and 
    # cals is calories/100g for each item
    # prot is grams protein/100g item
    # fat and carb similar to prot
    ncenters = length(centers)
    coefs ~ MvNormal([0.0 for i in 1:nitem*nregion*ncenters],10.0)
    offsetlog ~ MvNormal([log(5.0) for i in 1:nitem*nregion],log(5.0)/2.0)
    offset = reshape(exp.(offsetlog),(nitem,nregion))
    coefsm = reshape(coefs,(ncenters,nitem,nregion));
    measerr ~ Gamma(20.0,.5/19)
    quantlogs ~ MvNormal([log(20.0) for i in 1:nitem],log(2.0)) # quantity of item in basket in 100g increments, 20 = 2kg, 2kg * 4 = 20kg upper end ish for each quantity
    quants = exp.(quantlogs)
    alldates = round(minimum(date)):1.0/4:round(maximum(date))
    prices = zeros(typeof(quants[1]),length(alldates),nitem,nregion)
    cost = zeros(typeof(quants[1]),length(alldates),nitem,nregion)
    ## predict price with the RBF model for every date, every region, every item..
    ## utilize those prices which are known to inform the model through a likelihood

    ## include the measured data on prices through a likelihood
    for (d,i,r,p) in zip(date,item,region,price)
        pred = rbfeval(d,centers,rbfsc,view(coefsm,:,i,r),offset[i,r])
        Turing.@addlogprob!(logpdf(Normal(0.0,measerr),pred-p))
    end
    # using the coefficients, estimate all the prices quarterly...
    for (d,i,r) in Iterators.product(1:length(alldates),1:nitem,1:nregion)
        prices[d,i,r] = rbfeval(alldates[d],centers,rbfsc,view(coefsm,:,i,r),offset[i,r])
    end
    ## establish prior on quantities such that quantities which result in 2000 cal/day +- 50 cal are much more probable
    Turing.@addlogprob!(logpdf(Normal(2000.0,25.0),dot(quants, cals) /(365.0/12.0)))
    ## establish balanced diet... around 30%,30%,40% protein, fat, carbs
    macronuts = [dot(quants,prot) * 4.0 ,dot(quants,fat) * 9.0 ,dot(quants,carb) * 4.0 ] # calculate quantities in grams, multiply by calories / gram
    macronuts = macronuts/sum(macronuts) # normalize to get fraction of calories
    Turing.@addlogprob!(logpdf(Dirichlet([30,30,40]),macronuts)) # prior is near 30,30,40 ratio of calories from each source

    ## calculate the index.
    priceindex = zeros(typeof(price[1]*quants[1]),(length(alldates),nregion))
    for (d,r) in Iterators.product(1:length(alldates),1:nregion)
        priceindex[d,r] = dot(view(prices,d,:,r), quants) # dot product
    end
    return priceindex,quants
end


myprices.itemcat = categorical(myprices.item_code)
myprices.regioncat = categorical(myprices.region)
myprices.price = myprices.value .* 100.0 ./ myprices.quantg # price per 100g

@subset!(myprices,:year .>= 1999 )

ouritems = pricelistnutr[:,[:item_code, :calories, :protein,:fat,:carbs]]
ouritems.item_code = categorical(ouritems.item_code)
ouritems = @orderby(ouritems,:item_code)


foodmodel = cpifood(myprices.date,levelcode.(myprices.itemcat),length(levels(myprices.itemcat)),
                    levelcode.(myprices.regioncat),length(levels(myprices.regioncat)),collect(1999:3:2022),6.0,myprices.price,ouritems.calories,ouritems.protein,ouritems.fat,ouritems.carbs)



setadbackend(:reversediff)
Turing.setrdcache(true)

mapest = Optim.optimize(foodmodel,MAP(),LBFGS(),Optim.Options(x_tol=1e-5,f_tol=0.01,allow_f_increases=true,f_calls_limit=1_000_000,
    iterations=100_000,show_every=1000,time_limit=240))


samps = sample(foodmodel,NUTS(50,.7),50)





myitemsprcs = @chain @transform(leftjoin(myindex,interpprices; on= :item_code),:monthcost = :value .* :quantpermo) begin 
    @orderby(:date,:region) end

foodcost = @chain @by(myitemsprcs,[:date,:region],:monthcost = sum(:monthcost),:nitems = length(:monthcost)) begin
    @orderby(:date,:region)
    end

@df @subset(foodcost,:nitems .== 12) plot(:date,:monthcost; group = :region,legend=:topleft,title="Nominal Dollars 1 mo Food 1 Person")




```

## Lets create a food and shelter index... interpolating with Turing to create a stable index

